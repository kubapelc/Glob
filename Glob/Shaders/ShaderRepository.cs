using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;

namespace Glob
{
	public enum ShaderStage
	{
		Fragment = 35632,
		Vertex = 35633,
		Geometry = 36313,
		TesselationEvaluation = 36487,
		TesselationControl = 36488,
		Compute = 37305,
	}

	class ShaderRepository
	{
		const string _nullString = "";
		const string _extensionResolved = ".resolved";
		const string _extensionSpirv = ".spv";
		const string _extensionBinary = ".bin";
		//const string _compilerExe = "glslangValidator.exe";
		//const string _glslCachePath = "ResolvedCache";
		//const string _spirvCachePath = "CompiledCache";

		const string _shaderExtVertex = ".vert";
		const string _shaderExtTesselationControl = ".tesc";
		const string _shaderExtTesselationEvaluation = ".tese";
		const string _shaderExtGeometry = ".geom";
		const string _shaderExtFragment = ".frag";
		const string _shaderExtCompute = ".comp";

		Dictionary<string, Shader> _shaders;
		Dictionary<string, ShaderSource> _sources;
		Dictionary<string, ShaderSource> _sourcesByFullPath;

		Dictionary<ShaderPipelineDescription, ShaderPipeline> _pipelines;

		Device _device;
		FileSystemWatcher _watcher;

		/// <summary>
		/// Code that is added to the beginning of every shader as-is. Intended for #extension
		/// </summary>
		readonly internal string ShaderHeader;

		/// <summary>
		/// Version string to use when no version is provided by shader source code
		/// </summary>
		internal string DefaultVersionString;

		internal ShaderRepository(Device device, string shaderHeader = "", string defaultVersion = "430")
		{
			DefaultVersionString = defaultVersion;
			ShaderHeader = shaderHeader;
			
			_device = device;
			_shaders = new Dictionary<string, Shader>();
			_sources = new Dictionary<string, ShaderSource>();
			_sourcesByFullPath = new Dictionary<string, ShaderSource>();
			_pipelines = new Dictionary<ShaderPipelineDescription, ShaderPipeline>();

			// Create null shader source
			_sources.Add(_nullString, ShaderSource.CreateNullSource(_device, DefaultVersionString));
		}

		internal ShaderPipeline GetShaderPipeline(Shader vertex, Shader tescontrol, Shader teseval, Shader geometry,
			Shader fragment, Shader compute)
		{
			ShaderPipelineDescription desc = new ShaderPipelineDescription()
			{
				Vertex = vertex,
				TesselationControl = tescontrol,
				TesselationEvaluation = teseval,
				Geometry = geometry,
				Fragment = fragment,
				Compute = compute
			};

			if(_pipelines.ContainsKey(desc))
				return _pipelines[desc];
			
			ShaderPipeline pipeline = new ShaderPipeline(desc);

			_pipelines.Add(desc, pipeline);

			desc.Vertex?.Pipelines.Add(pipeline);
			desc.TesselationControl?.Pipelines.Add(pipeline);
			desc.TesselationEvaluation?.Pipelines.Add(pipeline);
			desc.Geometry?.Pipelines.Add(pipeline);
			desc.Fragment?.Pipelines.Add(pipeline);
			desc.Compute?.Pipelines.Add(pipeline);

			return pipeline;
		}

		static string GetMacrosHash(List<Tuple<string, string>> macros)
		{
			string s = "";

			for(int i = 0; i < macros.Count; i++)
			{
				s += macros[i].Item1 + "=" + macros[i].Item2 + ";";
			}

			return s.GetHashCode().ToString("X8");
		}

		static string GetShaderFileKey(string filename, List<Tuple<string, string>> macros)
		{
			return filename + "_" + GetMacrosHash(macros);
		}

		internal Shader GetShader(string filename, List<Tuple<string, string>> macros = null)
		{
			if(macros == null)
				macros = new List<Tuple<string, string>>();

			// Try to find the required shader in the cache
			string key = GetShaderFileKey(filename, macros);
			if(_shaders.ContainsKey(key))
			{
				return _shaders[key];
			}

			var source = GetShaderSource(filename);
			var shader = new Shader(_device, StageFromExtension(filename), source, macros);
			source.Usages.Add(shader);

			_shaders.Add(key, shader);
			Compile(shader, true);

			// TODO: shader bytecode caching
			//Stream bytecodeStream = _device.FileManager.GetStream(_device.FileManager.GetPathShaderCacheCompiled(key));

			//if(bytecodeStream != null)
			//{
			//	byte[] bytecode = null;
			//	using(BinaryReader br = new BinaryReader(bytecodeStream))
			//	{
			//		bytecode = br.ReadBytes((int)bytecodeStream.Length);
			//	}

			//	shader.CompileFromBytecode(bytecode);
			//}

			return shader;
		}

		internal ShaderSource GetShaderSource(string filename)
		{
			if(_sources.ContainsKey(filename))
				return _sources[filename];

			Stream sourceStream = _device.FileManager.GetStream(_device.FileManager.GetPathShaderSource(filename));

			if(sourceStream == null)
			{
				// File not found msg should be generated by the FileManager
				_device.TextOutput.Print(OutputTypeGlob.Debug, "Cannot open shader source file: " + filename);
				return _sources[_nullString];
			}

			var shaderSource = new ShaderSource(_device);
			shaderSource.Filename = filename;

			string sourceCode;

			using(StreamReader sr = new StreamReader(sourceStream))
			{
				sourceCode = sr.ReadToEnd();
			}
			
			_sources.Add(filename, shaderSource);
			_sourcesByFullPath.Add(Path.GetFullPath(_device.FileManager.GetPathShaderSource(filename)), shaderSource);

			shaderSource.Parse(this, sourceCode);

			return shaderSource;
		}

		internal void AddDependency(ShaderSource source, ShaderSource target)
		{
			source.Dependencies.Add(target);
			target.Inclusions.Add(source);
		}

		void ClearReferencesTo(ShaderSource source)
		{
			foreach(var dependency in source.Dependencies)
			{
				dependency.Inclusions.Remove(source);
			}
			foreach(var inclusion in source.Inclusions)
			{
				inclusion.Dependencies.Remove(source);
			}
			source.Dependencies.Clear();
			source.Inclusions.Clear();
		}

		void Compile(Shader shader, bool useCachedBinary) // useCachedBinary for future shader bytecode caching
		{
			var resolved = shader.BaseSource.GetResolvedGlsl(this, shader);

			string resolvedFileName = _device.FileManager.GetPathShaderCacheResolved(shader.BaseSource.Filename + _extensionResolved);
			//string compiledFileName = _device.FileManager.GetPathShaderCacheCompiled(GetShaderFileKey(Path.GetFileNameWithoutExtension(source.Filename), macros) + _extensionSpirv);

			//string resolvedFileNameWithShaderDir = Path.Combine(_device.ShaderFolderPath, resolvedFileName);

			Directory.CreateDirectory(Path.GetDirectoryName(resolvedFileName));
			try
			{
				using(StreamWriter sw = new StreamWriter(new FileStream(resolvedFileName, FileMode.Create)))
				{
					sw.Write(resolved.Code);
					sw.Flush();
				}
			}
			catch(IOException e)
			{
				this._device.TextOutput.Print(OutputTypeGlob.PerformanceWarning, "Failed to write resolved shader source: " + e.Message);
			}
			
			
			shader.CompileFromSource(resolved);

			// Shader SPIRV compilation using glsLangCompiler for Vulkan
			/*
			StringBuilder args = new StringBuilder();

			args.Append("-g -q ");
			args.Append("-S " + StageStringFromFlags(stage) + " ");

			args.Append("-o " + compiledFileName + " ");

			foreach(Tuple<string, string> macro in macros)
			{
				args.Append("-D");
				args.Append(macro.Item1);
				args.Append('=');
				args.Append(macro.Item2);
				args.Append(' ');
			}
			
			args.Append("-V " + resolvedFileName);

			var info = new ProcessStartInfo()
			{
				FileName = _device.FileManager.GetPathShaderSource(_compilerExe),
				RedirectStandardOutput = true,
				UseShellExecute = false,
				Arguments = args.ToString(),
				WorkingDirectory = Path.GetFullPath(_device.FileManager.GetPathShaderSource("")),
			};

			var process = Process.Start(info);

			_device.TextOutput.Print(OutputTypeGlob.Debug, _compilerExe + " shader compiler output:");

			string stdout = process.StandardOutput.ReadToEnd();

			var lines = Regex.Split(stdout, "\r\n|\r|\n");

			StringBuilder outputSb = new StringBuilder();

			foreach(var line in lines)
			{
				var match = Regex.Match(line, @"^ERROR:.*:([0-9]+):.*$");
				outputSb.AppendLine(line);
				if(match.Success)
				{
					int lineNum = int.Parse(match.Groups[1].Value);
					outputSb.AppendLine("At: " + resolved.GetLineOrigin(lineNum));
				}
			}

			_device.TextOutput.Print(OutputTypeGlob.Debug, outputSb.ToString());
			*/
		}

		// For glsLang args
		string StageStringFromFlags(ShaderStage stage)
		{
			switch(stage)
			{
				case ShaderStage.Vertex:
					{
						return "vert";
					}
				case ShaderStage.TesselationControl:
					{
						return "tesc";
					}
				case ShaderStage.TesselationEvaluation:
					{
						return "tese";
					}
				case ShaderStage.Geometry:
					{
						return "geom";
					}
				case ShaderStage.Fragment:
					{
						return "frag";
					}
				case ShaderStage.Compute:
					{
						return "comp";
					}
			}
			throw new Exception("Invalid shader stage: " + stage.ToString());
		}

		// Shader stage from file extension
		ShaderStage StageFromExtension(string filename)
		{
			string ext = Path.GetExtension(filename);
			if(ext.Equals(_shaderExtVertex))
				return ShaderStage.Vertex;
			if(ext.Equals(_shaderExtTesselationControl))
				return ShaderStage.TesselationControl;
			if(ext.Equals(_shaderExtTesselationEvaluation))
				return ShaderStage.TesselationEvaluation;
			if(ext.Equals(_shaderExtGeometry))
				return ShaderStage.Geometry;
			if(ext.Equals(_shaderExtFragment))
				return ShaderStage.Fragment;
			return ShaderStage.Compute;
		}

		void InvalidateSource(string fullpath)
		{
			// Assume that filename is usable as a key into the source dictionary

			if(!_sourcesByFullPath.ContainsKey(fullpath))
				return; // Not loaded yet, thus don't care

			var source = _sourcesByFullPath[fullpath];

			InvalidateSource(source);
		}

		void InvalidateSource(ShaderSource source)
		{
			// Load new source
			string code;
			Stream sourceStream = _device.FileManager.GetStream(_device.FileManager.GetPathShaderSource(source.Filename));

			if(sourceStream == null)
			{
				_device.TextOutput.Print(OutputTypeGlob.Warning, "Cannot open shader source file: " + source.Filename + "; using cached source code instead");
				return;
			}
			else
			{
				using(StreamReader sr = new StreamReader(sourceStream))
				{
					code = sr.ReadToEnd();
				}
			}

			var inclusions = source.Inclusions.ToList();

			ClearReferencesTo(source);
			
			// Create new references
			source.Parse(this, code);

			var allUsages = inclusions.Union(source.Inclusions);

			// Invalidate #include usages
			foreach(var usage in allUsages)
			{
				InvalidateSource(usage);
			}

			// Invalidate shaders that use this source file as base source
			foreach(Shader shader in source.Usages)
			{
				Compile(shader, false);
				// Invalidate pipelines
				foreach(ShaderPipeline pipeline in shader.Pipelines)
				{
					pipeline.RebuildShaderPipeline();
				}
			}
		}

		Object _fileWatcherSync;
		bool _filesChanged = false;
		List<string> _changedFiles;

		internal void Update()
		{
			if(_filesChanged)
			{
				List<string> changes;
				lock(_fileWatcherSync)
				{
					_filesChanged = false;
					changes = _changedFiles.ToList();
					_changedFiles.Clear();
				}

				foreach(string change in changes)
				{
					InvalidateSource(Path.GetFullPath(change));
				}
			}
		}

		internal void StartFileWatcher(string path)
		{
			_fileWatcherSync = new Object();
			_changedFiles = new List<string>();

			_watcher = new FileSystemWatcher(path, "*");
			_watcher.Changed += (sender, args) =>
			{
				OnFileChanged(args.FullPath);
			};
			_watcher.Renamed += (sender, args) =>
			{
				OnFileChanged(args.FullPath);
				OnFileChanged(args.OldFullPath);
			};

			_watcher.EnableRaisingEvents = true;
		}

		void OnFileChanged(string fullpath)
		{
			Thread.Sleep(10);
			lock (_fileWatcherSync)
			{
				_changedFiles.Add(fullpath);
				_filesChanged = true;
			}
		}
	}
}
